{"ast":null,"code":"var d3 = require('d3');\n\nexports.calculateScales = function (chartWidth, chartHeight, xValues, yValues) {\n  var xScale, yScale;\n\n  if (xValues.length > 0 && Object.prototype.toString.call(xValues[0]) === '[object Date]') {\n    xScale = d3.time.scale().range([0, chartWidth]);\n  } else {\n    xScale = d3.scale.linear().range([0, chartWidth]);\n  }\n\n  xScale.domain(d3.extent(xValues));\n\n  if (yValues.length > 0 && Object.prototype.toString.call(yValues[0]) === '[object Date]') {\n    yScale = d3.time.scale().range([chartHeight, 0]);\n  } else {\n    yScale = d3.scale.linear().range([chartHeight, 0]);\n  }\n\n  yScale.domain(d3.extent(yValues));\n  return {\n    xScale: xScale,\n    yScale: yScale\n  };\n}; // debounce from Underscore.js\n// MIT License: https://raw.githubusercontent.com/jashkenas/underscore/master/LICENSE\n// Copyright (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative\n// Reporters & Editors\n\n\nexports.debounce = function (func, wait, immediate) {\n  var timeout;\n  return function () {\n    var context = this,\n        args = arguments;\n\n    var later = function later() {\n      timeout = null;\n\n      if (!immediate) {\n        func.apply(context, args);\n      }\n    };\n\n    var callNow = immediate && !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n    if (callNow) func.apply(context, args);\n  };\n};\n\nexports.flattenData = function (data, xAccessor, yAccessor) {\n  var allValues = [];\n  var xValues = [];\n  var yValues = [];\n  var coincidentCoordinateCheck = {};\n  data.forEach(function (series, i) {\n    series.values.forEach(function (item, j) {\n      var x = xAccessor(item); // Check for NaN since d3's Voronoi cannot handle NaN values\n      // Go ahead and Proceed to next iteration since we don't want NaN\n      // in allValues or in xValues or yValues\n\n      if (isNaN(x)) {\n        return;\n      }\n\n      xValues.push(x);\n      var y = yAccessor(item); // when yAccessor returns an object (as in the case of candlestick)\n      // iterate over the keys and push all the values to yValues array\n\n      var yNode;\n\n      if (typeof y === 'object' && Object.keys(y).length > 0) {\n        Object.keys(y).forEach(function (key) {\n          // Check for NaN since d3's Voronoi cannot handle NaN values\n          // Go ahead and Proceed to next iteration since we don't want NaN\n          // in allValues or in xValues or yValues\n          if (isNaN(y[key])) {\n            return;\n          }\n\n          yValues.push(y[key]); // if multiple y points are to be plotted for a single x\n          // as in the case of candlestick, default to y value of 0\n\n          yNode = 0;\n        });\n      } else {\n        // Check for NaN since d3's Voronoi cannot handle NaN values\n        // Go ahead and Proceed to next iteration since we don't want NaN\n        // in allValues or in xValues or yValues\n        if (isNaN(y)) {\n          return;\n        }\n\n        yValues.push(y);\n        yNode = y;\n      }\n\n      var xyCoords = x + \"-\" + yNode;\n\n      if (coincidentCoordinateCheck.hasOwnProperty(xyCoords)) {\n        // Proceed to next iteration if the x y pair already exists\n        // d3's Voronoi cannot handle NaN values or coincident coords\n        // But we push them into xValues and yValues above because\n        // we still may handle them there (labels, etc.)\n        return;\n      }\n\n      coincidentCoordinateCheck[xyCoords] = '';\n      var pointItem = {\n        coord: {\n          x: x,\n          y: yNode\n        },\n        d: item,\n        id: series.name + j,\n        series: series,\n        seriesIndex: i\n      };\n      allValues.push(pointItem);\n    });\n  });\n  return {\n    allValues: allValues,\n    xValues: xValues,\n    yValues: yValues\n  };\n};\n\nexports.shade = function (hex, percent) {\n  var R, G, B, red, green, blue, number;\n  var min = Math.min,\n      round = Math.round;\n\n  if (hex.length !== 7) {\n    return hex;\n  }\n\n  number = parseInt(hex.slice(1), 16);\n  R = number >> 16;\n  G = number >> 8 & 0xFF;\n  B = number & 0xFF;\n  red = min(255, round((1 + percent) * R)).toString(16);\n  if (red.length === 1) red = '0' + red;\n  green = min(255, round((1 + percent) * G)).toString(16);\n  if (green.length === 1) green = '0' + green;\n  blue = min(255, round((1 + percent) * B)).toString(16);\n  if (blue.length === 1) blue = '0' + blue;\n  return \"#\" + red + green + blue;\n};","map":null,"metadata":{},"sourceType":"script"}